(defgeneric execute-rules (instans)
  (:method ((this instans))
    (let* ((policy (instans-execution-policy this))
	   (queue (instans-rule-instance-queue this)))
      (case policy
	(:first
	 (rule-instance-queue-execute-first queue))
	(:snapshot
	 (rule-instance-queue-execute-snapshot queue))
	(:repeat-first
	 (loop while (rule-instance-queue-execute-first queue)))
	(:repeat-snapshot
	 (loop while (rule-instance-queue-execute-snapshot queue)))
	(t (error* "Unknown execution policy ~A" policy))))))

(defgeneric execute-system (instans)
  (:method ((this instans))
    (initialize-execution this)
    (let ((input-function (instans-input-function this))
	  (input-function-arguments (instans-input-function-arguments this)))
      (loop for input = (apply input-function input-function-arguments)
	    while input
	    do (incf (instans-input-count this))
	    do (let ((op (if (member (car input) '(:add :remove :add-exec-remove)) (pop input) :add)))
		 (case op
		   (:add
		    (loop for (s p o g) in input do (rete-add this s p o g))
		    (execute-rules this))
		   (:remove
		    (loop for (s p o g) in input do (rete-remove this s p o g))
		    (execute-rules this))
		   (:execute
		    (loop for (s p o g) in input do (rete-add this s p o g))
		    (execute-rules this)
		    (loop for (s p o g) in input do (rete-remove this s p o g)))
		   (t
		    (error* "Illegal op ~S" op))))))))

;; (defgeneric group-add-token (group aggr-join token)
;;   (:method ((this group) (aggr-join aggregate-join-node) token)
;;     (loop with prev-values = (group-aggr-values this)
;; 	  for prev-value = (pop prev-values)
;; 	  for (output-var input-var op scalars) in (aggregate-join-var-aggr-list aggr-join)
;; 	  collect output-var into output-vars
;; 	  collect (case op
;; 		    (sum (+ (or prev-value 0) (token-value aggr-join token input-var)))
;; 		    (min (if (null prev-value) (token-value aggr-join token input-var)
;; 			     (min prev-value (token-value aggr-join token input-var))))
;; 		    (max (if (null prev-value) (token-value aggr-join token input-var)
;; 			     (max prev-value (token-value aggr-join token input-var))))
;; 		    (sample (token-value aggr-join token input-var))
;; 		    (t (error* "Not implemented yet!")))
;; 	  into new-values
;; 	  finally (return (progn
;; 			    (incf (group-input-token-count this))
;; 			    (setf (group-aggr-values this) new-values)
;; 			    (setf (group-token this) (make-token aggr-join nil output-vars new-values))))))) ; returns updated group-token

;; (defgeneric group-remove-token (group aggr-join token)
;;   (:method ((this group) (aggr-join aggregate-join-node) token)
;;     (cond ((zerop (decf (group-input-token-count this)))
;; 	   (setf (group-aggr-values this) nil)
;; 	   (setf (group-token this) nil)) ; returns nil
;; 	  (t
;; 	   (loop with prev-values = (group-aggr-values this)
;; 		 for prev-value = (pop prev-values)
;; 		 for (output-var input-var op scalars) in (aggregate-join-var-aggr-list aggr-join)
;; 		 collect output-var into output-vars
;; 		 collect (case op
;; 			   (sum (- prev-value (token-value aggr-join token input-var)))
;; 			   (min (if (null prev-value) (token-value aggr-join token input-var)
;; 				    (min prev-value (token-value aggr-join token input-var))))
;; 			   (max (if (null prev-value) (token-value aggr-join token input-var)
;; 				    (max prev-value (token-value aggr-join token input-var))))
;; 			   (sample (token-value aggr-join token input-var))
;; 			   (t (error* "Not implemented yet!")))
;; 		 into new-values
;; 		 finally (return (progn 
;; 				   (setf (group-aggr-values this) new-values)
;; 				   (setf (group-token this) (make-token aggr-join nil output-vars new-values))))))))) ; returns updated group-token

