;;; -*- Mode: Lisp; Syntax: COMMON-LISP; Base: 10; Package: INSTANS -*-
;;;
;;; Author: Esko Nuutila (esko.nuutila@aalto.fi)
;;;

(in-package #:instans)

(define-class keyword-table (bindings-table) ())

(define-class string-table (bindings-table) ())

(define-class prefix-table (bindings-table) ())

(define-class abstract-sparql-rdf-lexer (abstract-lexer)
  ((buffered-input-token :accessor lexer-buffered-input-token :initform nil)
   (delay-iri-expansion-p :accessor lexer-delay-iri-expansion-p :initform nil)
   (delayed-iris :accessor lexer-delayed-iris :initform nil)
   (prefix-table :accessor lexer-prefix-table :initarg :prefix-table)
   (keyword-table :accessor lexer-keyword-table :initarg :keyword-table :initform nil)
   (string-table :accessor lexer-string-table :initarg :string-table)
   (save-previous-comment-p :accessor lexer-save-previous-comment-p :initform nil)
   (previous-comment :accessor lexer-previous-comment :initform nil)
   (instans :accessor lexer-instans :initarg :instans)))

(define-class n-statements-lexer (abstract-sparql-rdf-lexer) ())

(define-class sparql-lexer (abstract-sparql-rdf-lexer) ())

(define-class trig-lexer (abstract-sparql-rdf-lexer) ())

(define-class turtle-lexer (trig-lexer) ())

(defmethod initialize-instance :after ((this abstract-sparql-rdf-lexer) &key base &allow-other-keys)
  (setf (lexer-string-table this) (make-instance 'string-table :case-sensitive-p t))
  (let ((keyword-table (setf (lexer-keyword-table this) (make-instance 'keyword-table :case-sensitive-p nil))))
    (loop for item in (lexer-keywords this)
	  for binding = (add-table-binding keyword-table (first item) :case-sensitive-p (third item))
	  do (setf (table-binding-value binding) (second item))))
  (setf (lexer-prefix-table this) (make-instance 'prefix-table :case-sensitive-p t))
  (bind-prefix this "xsd" (parse-iri "http://www.w3.org/2001/XMLSchema#"))
  (unless (null base) (bind-prefix this "BASE" base)))

(defmethod initialize-instance :before ((this n-statements-lexer) &rest keys &key &allow-other-keys)
  (remf keys :base))

(defmethod initialize-instance :after ((this sparql-lexer) &key &allow-other-keys)
  (setf (lexer-save-previous-comment-p this) t))

(defgeneric lexer-keywords (abstract-sparql-rdf-lexer)
  (:method ((this sparql-lexer))
    '(("a" A-TERMINAL t)
      ("ABS" ABS-TERMINAL)
      ("ADD" ADD-TERMINAL)
      ("ALL" ALL-TERMINAL)
      ("AS" AS-TERMINAL)
      ("ASC" ASC-TERMINAL)
      ("ASK" ASK-TERMINAL)
      ("AVG" AVG-TERMINAL)
      ("BASE" BASE-TERMINAL)
      ("BIND" BIND-TERMINAL)
      ("BNODE" BNODE-TERMINAL)
      ("BOUND" BOUND-TERMINAL)
      ("BY" BY-TERMINAL)
      ("CEIL" CEIL-TERMINAL)
      ("CLEAR" CLEAR-TERMINAL)
      ("COALESCE" COALESCE-TERMINAL)
      ("CONCAT" CONCAT-TERMINAL)
      ("CONSTRUCT" CONSTRUCT-TERMINAL)
      ("CONTAINS" CONTAINS-TERMINAL)
      ("COPY" COPY-TERMINAL)
      ("COUNT" COUNT-TERMINAL)
      ("CREATE" CREATE-TERMINAL)
      ("DATA" DATA-TERMINAL)
      ("DATATYPE" DATATYPE-TERMINAL)
      ("DAY" DAY-TERMINAL)
      ("DEFAULT" DEFAULT-TERMINAL)
      ("DELETE" DELETE-TERMINAL)
      ("DELETE DATA" DELETE-DATA-TERMINAL)
      ("DELETE WHERE" DELETE-WHERE-TERMINAL)
      ("DESC" DESC-TERMINAL)
      ("DESCRIBE" DESCRIBE-TERMINAL)
      ("DISTINCT" DISTINCT-TERMINAL)
      ("DROP" DROP-TERMINAL)
      ("ENCODE_FOR_URI" ENCODE_FOR_URI-TERMINAL)
      ("EXISTS" EXISTS-TERMINAL)
      ("FALSE" FALSE-TERMINAL)
      ("FILTER" FILTER-TERMINAL)
      ("FLOOR" FLOOR-TERMINAL)
      ("FROM" FROM-TERMINAL)
      ("GRAPH" GRAPH-TERMINAL)
      ("GROUP" GROUP-TERMINAL)
      ("GROUP_CONCAT" GROUP_CONCAT-TERMINAL)
      ("HAVING" HAVING-TERMINAL)
      ("HOURS" HOURS-TERMINAL)
      ("IF" IF-TERMINAL)
      ("IN" IN-TERMINAL)
      ("INSERT" INSERT-TERMINAL)
      ("INSERT DATA" INSERT-DATA-TERMINAL)
      ("INTO" INTO-TERMINAL)
      ("IRI" IRI-TERMINAL)
      ("ISBLANK" ISBLANK-TERMINAL)
      ("ISIRI" ISIRI-TERMINAL)
      ("ISLITERAL" ISLITERAL-TERMINAL)
      ("ISNUMERIC" ISNUMERIC-TERMINAL)
      ("ISURI" ISURI-TERMINAL)
      ("LANG" LANG-TERMINAL)
      ("LANGMATCHES" LANGMATCHES-TERMINAL)
      ("LCASE" LCASE-TERMINAL)
      ("LIMIT" LIMIT-TERMINAL)
      ("LOAD" LOAD-TERMINAL)
      ("MAX" MAX-TERMINAL)
      ("MD5" MD5-TERMINAL)
      ("MIN" MIN-TERMINAL)
      ("MINUS" MINUS-TERMINAL)
      ("MINUTES" MINUTES-TERMINAL)
      ("MONTH" MONTH-TERMINAL)
      ("MOVE" MOVE-TERMINAL)
      ("NAMED" NAMED-TERMINAL)
      ("NOT" NOT-TERMINAL)
      ("NOW" NOW-TERMINAL)
      ("OFFSET" OFFSET-TERMINAL)
      ("OPTIONAL" OPTIONAL-TERMINAL)
      ("ORDER" ORDER-TERMINAL)
      ("PREFIX" PREFIX-TERMINAL)
      ("RAND" RAND-TERMINAL)
      ("REDUCED" REDUCED-TERMINAL)
      ("REGEX" REGEX-TERMINAL)
      ("REPLACE" REPLACE-TERMINAL)
      ("ROUND" ROUND-TERMINAL)
      ("SAMETERM" SAMETERM-TERMINAL)
      ("SAMPLE" SAMPLE-TERMINAL)
      ("SECONDS" SECONDS-TERMINAL)
      ("SELECT" SELECT-TERMINAL)
      ("SEPARATOR" SEPARATOR-TERMINAL)
      ("SERVICE" SERVICE-TERMINAL)
      ("SHA1" SHA1-TERMINAL)
      ("SHA256" SHA256-TERMINAL)
      ("SHA384" SHA384-TERMINAL)
      ("SHA512" SHA512-TERMINAL)
      ("SILENT" SILENT-TERMINAL)
      ("STR" STR-TERMINAL)
      ("STRAFTER" STRAFTER-TERMINAL)
      ("STRBEFORE" STRBEFORE-TERMINAL)
      ("STRDT" STRDT-TERMINAL)
      ("STRENDS" STRENDS-TERMINAL)
      ("STRLANG" STRLANG-TERMINAL)
      ("STRLEN" STRLEN-TERMINAL)
      ("STRSTARTS" STRSTARTS-TERMINAL)
      ("STRUUID" STRUUID-TERMINAL)
      ("SUBSTR" SUBSTR-TERMINAL)
      ("SUM" SUM-TERMINAL)
      ("TIMEZONE" TIMEZONE-TERMINAL)
      ("TO" TO-TERMINAL)
      ("TRUE" TRUE-TERMINAL)
      ("TZ" TZ-TERMINAL)
      ("UCASE" UCASE-TERMINAL)
      ("UNDEF" UNDEF-TERMINAL)
      ("UNION" UNION-TERMINAL)
      ("URI" URI-TERMINAL)
      ("USING" USING-TERMINAL)
      ("UUID" UUID-TERMINAL)
      ("VALUES" VALUES-TERMINAL)
      ("WHERE" WHERE-TERMINAL)
      ("WITH" WITH-TERMINAL)
      ("YEAR" YEAR-TERMINAL)
					;;; Begin Extension
      ("ASSERT" ASSERT-TERMINAL)
      ("ERROR" ERROR-TERMINAL)
      ("INPUT" INPUT-TERMINAL)
      ("OUTPUT" OUTPUT-TERMINAL)
      ("SOLUTIONS" SOLUTIONS-TERMINAL)
      ("TRIPLES" TRIPLES-TERMINAL)
      ("TEST" TESTS-TERMINAL)
					;;; End Extension
      ))
  (:method ((this trig-lexer))
    '(("a" A-TERMINAL t)
      ("BASE" BASE-TERMINAL)
      ("FALSE" FALSE-TERMINAL)
      ("GRAPH" GRAPH-TERMINAL)
      ("PREFIX" PREFIX-TERMINAL)
      ("TRUE" TRUE-TERMINAL)
      ("@base" @BASE-TERMINAL t)
      ("@prefix" @PREFIX-TERMINAL t)))
  (:method ((this abstract-sparql-rdf-lexer))
    nil))

(defun select-keyword (lexer buf &key (not-exists-error-p t))
  (let ((binding (get-table-binding (lexer-keyword-table lexer) (chbuf-contents buf) :end (chbuf-index buf))))
    (cond (binding
	   (return-input-token lexer (table-binding-value binding) (table-binding-key binding)))
	  (not-exists-error-p
	   (lexer-error lexer "Unrecognized keyword ~S" (chbuf-string buf))))))
;	   (error* "Unrecognized keyword ~S" (chbuf-string buf))

(defgeneric lexer-delay-iri-expansion (lexer bool)
  (:method ((this abstract-sparql-rdf-lexer) bool)
    (cond ((lexer-delay-iri-expansion-p this)
	   (cond ((not bool)
		  (loop for iri in (lexer-delayed-iris this) do (expand-iri (lexer-base this) iri)))
		 (t
		  (error* "Already delaying iri expansion!"))))
	  ((not bool)
	   (error* "Not delaying iri expansion?")))
    (setf (lexer-delay-iri-expansion-p this) bool)))

(defgeneric lexer-expand-iri (lexer iri-string)
  (:method ((this n-statements-lexer) iri-string)
    (let ((iri (parse-iri iri-string)))
      (cond ((rdf-iri-scheme iri) iri)
	    (t
	     (lexer-error this "Relative IRIs not allowed in N-Triples and N-Quads")))))
  (:method ((this abstract-sparql-rdf-lexer) iri-string)
    (cond ((lexer-delay-iri-expansion-p this)
	   (let ((iri (parse-iri iri-string)))
	     (push iri (lexer-delayed-iris this))
	     iri))
	  (t
	   (multiple-value-bind (expanded error-msg)
	       (expand-iri (lexer-base this) iri-string)
	     (cond ((null error-msg) expanded)
		   (t
		    (lexer-error this error-msg))))))))

(defgeneric canonize-string (lexer buf &optional start end)
  (:method ((this abstract-sparql-rdf-lexer) buf &optional (start 0) (end (chbuf-index buf)))
    (let* ((table (lexer-string-table this))
	   (binding (get-table-binding table (chbuf-contents buf) :start start :end end)))
;      (inform "canonize-string binding = ~S, ~S (~D ~D of ~S" binding (chbuf-string buf start end) start end (chbuf-contents buf))
      (cond ((null binding)
	     (setf binding (add-table-binding table (chbuf-contents buf) :start start :end end))
	     (setf (table-binding-value binding) (characters-to-string (chbuf-contents buf) start end)))
	    (t
	     (table-binding-value binding))))))

(defgeneric set-lexer-base (lexer base)
  (:method ((this abstract-sparql-rdf-lexer) base)
    (bind-prefix this "BASE" base)))

(defgeneric lexer-base (lexer)
  (:method ((this abstract-sparql-rdf-lexer))
    (resolve-prefix this "BASE")))

(defgeneric resolve-prefix (lexer prefix-or-buf)
  (:method ((this abstract-sparql-rdf-lexer) (buf chbuf))
    (let* ((table (lexer-prefix-table this))
	   (binding (get-table-binding table (chbuf-contents buf) :start 0 :end (chbuf-index buf))))
      (and binding (table-binding-value binding))))
  (:method ((this abstract-sparql-rdf-lexer) prefix)
    (let* ((table (lexer-prefix-table this))
	   (binding (get-table-binding table prefix)))
      (and binding (table-binding-value binding)))))

(defgeneric bind-prefix (lexer prefix expansion)
  (:method ((this abstract-sparql-rdf-lexer) prefix expansion)
    (let* ((table (lexer-prefix-table this))
	   (binding (get-table-binding table prefix)))
      (when (null binding)
	(setf binding (add-table-binding table prefix)))
      (setf (table-binding-value binding) expansion))))

(defgeneric pname-to-iri (lexer prefix &optional suffix)
  (:method ((this abstract-sparql-rdf-lexer) prefix &optional suffix)
    (let ((prefix-iri (resolve-prefix this prefix)))
      (and prefix-iri (lexer-expand-iri this (concatenate 'string (rdf-iri-string prefix-iri) suffix))))))

;;; This does not use next-input-token!!!

(defmethod get-input-token ((lexer n-statements-lexer))
  (catch 'input-token
    (progn
      (let ((eolp (skip-whitespace-and-comments lexer)))
	(cond ((null (peekch lexer))
	       (close (lexer-input-stream lexer))
	       (return-input-token lexer :eof "End of input"))
	      (eolp (return-input-token lexer 'EOL-TOKEN "End of line"))
	      ((get-char-if-looking-at lexer #\.)
	       (return-input-token lexer '.-TERMINAL "."))
	      ((get-char-if-looking-at lexer #\^)
	       (cond ((get-char-if-looking-at lexer #\^) (return-input-token lexer '^^-TERMINAL "^^"))
		     (t (lexer-error lexer "Unrecognized input-token ~C" (peekch lexer)))))
	      ((get-char-if-looking-at lexer #\@)
	       (eat-at lexer))
	      ((get-char-if-looking-at lexer #\<)
	       (eat-iri lexer))
	      ((get-char-if-looking-at lexer #\")
		 ;;; Check this
	       (eat-string-literal lexer #\" '(#x22 #x5C #xA #xD) 'STRING_LITERAL_QUOTE-TERMINAL nil))
	      ((get-char-if-looking-at lexer #\_)
	       (eat-blank-node-label lexer))
	      (t (lexer-error lexer "Unrecognized input-token ~C" (get-char lexer))))))))

(defmethod get-input-token ((lexer trig-lexer))
  (let* ((input-token1 (if (lexer-buffered-input-token lexer)
			   (prog1 (lexer-buffered-input-token lexer)
			     (setf (lexer-buffered-input-token lexer) nil))
			   (next-input-token lexer)))
	 (type1 (input-token-type input-token1)))
					;    (inform "get-input-token i1=~S, t1=~S" input-token1 type1)
    (cond ((member type1 '(|[-TERMINAL|))
	   (let* ((input-token2 (next-input-token lexer))
		  (type2 (input-token-type input-token2)))
					;	     (inform "get-input-token i2=~S, t2=~S" input-token2 type2)
	     (cond ((and (eq type1 '|[-TERMINAL|) (eq type2 '|]-TERMINAL|))
		    (make-input-token :type 'ANON-TERMINAL :value "ANON"))
		   (t
		    (setf (lexer-buffered-input-token lexer) input-token2)
		    input-token1))))
	  (t input-token1))))

(defmethod get-input-token ((lexer sparql-lexer))
  (let* ((input-token1 (if (lexer-buffered-input-token lexer)
			   (prog1 (lexer-buffered-input-token lexer)
			     (setf (lexer-buffered-input-token lexer) nil))
			   (next-input-token lexer)))
	 (type1 (input-token-type input-token1)))
					;    (inform "get-input-token i1=~S, t1=~S" input-token1 type1)
    (cond ((member type1 '(INSERT-TERMINAL DELETE-TERMINAL |(-TERMINAL| |[-TERMINAL|))
	   (let* ((input-token2 (next-input-token lexer))
		  (type2 (input-token-type input-token2)))
					;	     (inform "get-input-token i2=~S, t2=~S" input-token2 type2)
	     (cond ((and (eq type1 'INSERT-TERMINAL) (eq type2 'DATA-TERMINAL))
		    (make-input-token :type 'INSERT-DATA-TERMINAL :value "INSERT DATA"))
		   ((and (eq type1 'DELETE-TERMINAL) (eq type2 'DATA-TERMINAL))
		    (make-input-token :type 'DELETE-DATA-TERMINAL :value "DELETE DATA"))
		   ((and (eq type1 'DELETE-TERMINAL) (eq type2 'WHERE-TERMINAL))
		    (make-input-token :type 'DELETE-WHERE-TERMINAL :value "DELETE WHERE"))
		   ((and (eq type1 '|(-TERMINAL|) (eq type2 '|)-TERMINAL|))
		    (make-input-token :type 'NIL-TERMINAL :value (make-instance 'rdf-iri :string "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil")))
		   ((and (eq type1 '|[-TERMINAL|) (eq type2 '|]-TERMINAL|))
		    (make-input-token :type 'ANON-TERMINAL :value "ANON"))
		   (t
		    (setf (lexer-buffered-input-token lexer) input-token2)
		    input-token1))))
	  (t input-token1))))
