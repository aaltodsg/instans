
PREFIX :<http:example.org/default#>
PREFIX geo:<http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX ssn:<http://purl.oclc.org/NET/ssnx/ssn#>
PREFIX ep:<http://www.ontologydesignpatterns.org/cp/owl/eventprocessing.owl#>
PREFIX omgeo: <http://www.ontotext.com/owlim/geo#>
PREFIX ff: <http://factforge.net/>

# R0: Move everything from default graph to source
# Can be removed if input data gets directly read into <http://example.org/source/> instead of default

INSERT { GRAPH <http://example.org/source/> {
      ?sub ?pred ?obj } }
WHERE { ?sub ?pred ?obj }

# Semicolon separates queries and rules in INSTANS
;

# Stateless filter (EPA 1): Only events generated during business hours

INSERT { GRAPH <http://example.org/poststateless/> {
      ?event ?p1 ?o1 .
      ?h2 ?p2 ?o2 } }
WHERE {  GRAPH <http://example.org/source/> {
    ?event a ep:EventObject ;
           ?p1 ?o1 ;
           ep:hasEventObjectSamplingTime ?time .
           OPTIONAL { BIND ( IF (isBlank(?o1), ?o1, 0) as ?h2)
                  ?h2 ?p2 ?o2 }
    FILTER ( ( HOURS(?time) > 8 ) && ( HOURS(?time) < 17 ) ) } }

;

# Stateful filter (EPA 2): Only 1 event per hour

DELETE { GRAPH <http://example.org/memory/> { 
    ?mem :prevHour ?prevhour } }
INSERT { GRAPH <http://example.org/poststateful/> {
      ?event ?p1 ?o1 .
      ?h2 ?p2 ?o2 }
 GRAPH <http://example.org/memory/> { 
     [] :prevHour ?hour }  
}
WHERE { GRAPH <http://example.org/poststateless/> {
    ?event a ep:EventObject ;
           ?p1 ?o1 ;
           ep:hasEventObjectSamplingTime ?time .
    OPTIONAL { BIND ( IF (isBlank(?o1), ?o1, 0) as ?h2)
            ?h2 ?p2 ?o2 }
    }
   GRAPH <http://example.org/memory/> {
    OPTIONAL  { ?mem :prevHour ?prevhour }
  }
  BIND ( HOURS(?time) as ?hour)
  FILTER ( ?hour != COALESCE(?prevhour,-1) ) 
}

;

# Enrich (EPA 3): Enrich events with the name of the closest location
# If there are problems with the SERVICE-query, it can be temporarily replaced with BIND ( "Espoo" as ?label )

INSERT { GRAPH <http://example.org/translated/> { 
    ?event ex:locationName ?label } }
WHERE { GRAPH <http://example.org/poststateful/> { 
    ?event a ep:EventObject ;
    geo:Point [ geo:lat ?lat ; geo:long ?long ; ] .
    SERVICE <http://factforge.net/sparql> \{
       ?location omgeo:nearby(?lat ?long "1km"); 
                 ff:preferredLabel ?label } } }

; 

# Project (EPA 4): Delete information from the incoming events

INSERT {  GRAPH <http://example.org/projected/> { 
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] ;
           ep:hasEventObjectSamplingTime ?time } }
WHERE {  GRAPH <http://example.org/translated/> { 
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] ;
           ep:hasEventObjectSamplingTime ?time } }

;

# Split (EPA 5): Split into separate channels using original blank nodes.

INSERT { GRAPH <http://example.org/geoevents/> {
    ?event a ep:EventObject ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] }
  GRAPH <http://example.org/timeevents/> {
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
           ep:hasEventObjectSamplingTime ?time } }
WHERE { GRAPH <http://example.org/poststateful/> {
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] ;
           ep:hasEventObjectSamplingTime ?time } }

;

# Aggregate (EPA 6): Create new events out of the number of events observed in each hour

INSERT { GRAPH <http://example.org/eventcounts/> {
   [] a ep:EventObject ;
      :eventType :eventCount ;
      :hour ?hour ;
      :count ?nrevent } }
WHERE { 
  SELECT ?hour (COUNT(?event) as ?nrevent)
  WHERE { GRAPH <http://example.org/source/> {
      ?event a ep:EventObject ;
             ep:hasEventObjectSamplingTime ?time .
      BIND ( HOURS(?time) as ?hour ) } }
  GROUP BY ?hour }

;

# Compose (EPA 7): Combine two event streams into one

INSERT { GRAPH <http://example.org/combined/> {
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] ;
           ep:hasEventObjectSamplingTime ?time } }
WHERE { 
GRAPH <http://example.org/geoevents/> {
    ?event a ep:EventObject ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] }
  GRAPH <http://example.org/timeevents/> {
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
           ep:hasEventObjectSamplingTime ?time } }

;

# Transform (auxiliary rule): Create directional events

DELETE {  GRAPH <http://example.org/memory/> {
  ?mem ssn:Sensor ?sensor ;
       :prevLat ?prevlat ;
       :prevLong ?prevlong } }
INSERT { GRAPH <http://example.org/memory/> {
    [] ssn:Sensor ?sensor ;
       :prevLat ?lat ;
       :prevLong ?long  }
  GRAPH <http://example.org/directions/> {
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
	   :direction ?dir } }
WHERE { GRAPH <http://example.org/source/> {
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] . } 
  GRAPH <http://example.org/memory/> {
    OPTIONAL  { ?mem ssn:Sensor ?sensor ;
    	      	     :prevLat ?prevlat ;
                     :prevLong ?prevlong  }
      BIND ( IF ( ?lat > ?prevlat, "N", "") as ?latdir1)
      BIND ( IF ( ?lat < ?prevlat, "S", "") as ?latdir2)
      BIND ( IF ( ?long > ?prevlong, "E", "") as ?longdir1)
      BIND ( IF ( ?long < ?prevlong, "W", "") as ?longdir2) 
      BIND ( concat(?latdir1, ?latdir2, ?longdir1, ?longdir2) as ?dir )
} }

;

# Pattern Detection (EPA 8-1): Compare incoming pattern with pattern in database, advance index in memory if a match

DELETE {  GRAPH <http://example.org/memory/> {
  ?mem :patternindex ?memindex } }
INSERT { GRAPH <http://example.org/memory/> {
    [] :patternindex ?newindex } }
WHERE { GRAPH <http://example.org/directions/> {
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
	   :direction ?dir }
  GRAPH <http://example.org/memory/> {
    OPTIONAL  { ?mem :patternindex ?memindex } }
  GRAPH <http://example.org/pattern/> {
    ?pattern :index ?ptindex ;
             :value ?ptvalue }
  BIND ( COALESCE(?memindex+1,1) as ?newindex ) # COALESCE in case ?memindex not bound
  FILTER ( (?dir = ?ptvalue) && (?newindex = ?ptindex) )
}

;

# Pattern Detection (EPA 8-2): Reset index if the latest event does not match

DELETE {  GRAPH <http://example.org/memory/> {
  ?mem :patternindex ?memindex } }
WHERE { GRAPH <http://example.org/directions/> {
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
	   :direction ?dir }
  GRAPH <http://example.org/memory/> {
    ?mem :patternindex ?memindex }
  GRAPH <http://example.org/pattern/> {
    ?pattern :index ?ptindex ;
             :value ?ptvalue }
  FILTER ( (?dir != ?ptvalue) && (?memindex+1 = ?ptindex) )
}

;

# Pattern Detection (EPA 8-3): Insert an event into "patterndetect" channel, when the designated pattern is detected. Reset pattern index.

DELETE {  GRAPH <http://example.org/memory/> {
  ?mem :patternindex ?memindex } }
INSERT { GRAPH <http://example.org/patterndetect/> {
    [] a ep:EventObject ;
       :patterndetected "BackAndForth!" } }
WHERE { GRAPH <http://example.org/memory/> {
    ?mem :patternindex ?memindex }
    FILTER ( ?memindex = 2 )
}
