;;; -*- Mode: Lisp; Syntax: COMMON-LISP; Base: 10; Package: INSTANS -*-
;;;
;;; Author: Esko Nuutila (esko.nuutila@aalto.fi)
;;;

(in-package #:instans)

(defvar *triple-count* 0)
(defvar *triple-sizes* 0)

(defun term-size (x)
  (cond ((consp x)
	 (+ (term-size (car x)) (term-size (cdr x))))
	((stringp x)
	 (length x))
	(t 1)))

(defun triple-size (tr)
  (loop for x in tr
	sum (term-size x)))

(defun make-turtle-parser (&key (triples-callback nil))
  (let* ((triples (list nil))
	 (triples-last triples)
	 (lexer nil))
    (labels ((init () 
	       (initialize-uniquely-named-object-factories)
	       (set-base (parse-iri "http://"))
	       (clear-triples))
	     (set-prefix (prefix-binding expansion) (rebind-prefix lexer prefix-binding expansion))
	     (set-base (b) (set-lexer-base lexer b) (values))
	     (clear-triples ()
	       (setf triples (list nil))
	       (setf triples-last triples))
	     (get-triples ()
	       (let ((r (cdr triples)))
		 (incf *triple-count* (length r))
		 (incf *triple-sizes* (loop for tr in r sum (triple-size tr)))
		 (clear-triples)
		 r))
	     (emit (s p o)
	       (setf (cdr triples-last) (list (list s p o)))
	       (setf triples-last (cdr triples-last)))
	     (emit-subj-pred-obj-list (s pol)
	       (loop for (p . ol) in pol do (loop for o in ol do (emit s p o)))
	       s)
	     (expand-collection (col)
	       (cond ((null col) *rdf-nil*)
		     (t
		      (let ((subj (generate-rdf-blank-node))
			    (rest (expand-collection (cdr col))))
			(emit subj *rdf-rest* rest)
			(emit subj *rdf-first* (car col))
			subj)))))
      (with-ll1-parser (turtle-parser)
	((turtleDoc		  ::= (:REP0 statement) :RESULT (values))
	 (statement		  ::= (:OR directive (triples .-TERMINAL :RESULT (values))))
	 (directive		  ::= (:OR prefixID base sparqlPrefix sparqlBase) :RESULT (progn (inform "Directive") (values)))
	 (prefixID		  ::= ((@PREFIX-TERMINAL PNAME_NS-TERMINAL IRIREF-TERMINAL :RESULT (set-prefix $1 $2)) .-TERMINAL))
	 (base		  	  ::= ((@BASE-TERMINAL IRIREF-TERMINAL :RESULT (set-base $1)) .-TERMINAL))
	 (sparqlBase		  ::= (BASE-TERMINAL IRIREF-TERMINAL :RESULT (set-base $1)))
	 (sparqlPrefix	  	  ::= (PREFIX-TERMINAL PNAME_NS-TERMINAL IRIREF-TERMINAL :RESULT (set-prefix $1 $2)))
	 (triples		  ::= (:OR (subject predicateObjectList :RESULT (emit-subj-pred-obj-list $0 $1))
					   (blankNodePropertyList (:OPT predicateObjectList) :RESULT (emit-subj-pred-obj-list $0 (opt-value $1))))
				  :RESULT (progn (when triples-callback (funcall triples-callback (get-triples))) (values)))
	 (predicateObjectList	  ::= ((verb objectList :RESULT (cons $0 $1))
				       (:REP0 (|;-TERMINAL| (:OPT (verb objectList :RESULT (list (cons $0 $1)))) :RESULT (opt-value $1))))
				  :RESULT (cons $0 (apply #'append $1)))
	 (objectList		  ::= (object (:REP0 (|,-TERMINAL| object :RESULT $1)) :RESULT (cons $0 $1)))
	 (verb		  ::= (:OR predicate (A-TERMINAL :RESULT *rdf-type*)))
	 (subject		  ::= (:OR iri BlankNode collection))
	 (predicate		  ::= (iri))
	 (object		  ::= (:OR iri BlankNode collection blankNodePropertyList literal))
	 (literal		  ::= (:OR RDFLiteral NumericLiteral BooleanLiteral))
	 (blankNodePropertyList   ::= ([-TERMINAL predicateObjectList ]-TERMINAL :RESULT (emit-subj-pred-obj-list (generate-rdf-blank-node) $1)))
	 (collection		  ::= (|(-TERMINAL| (:REP0 object) |)-TERMINAL|) :RESULT (expand-collection $1))
	 (NumericLiteral	  ::= (:OR INTEGER-TERMINAL DECIMAL-TERMINAL DOUBLE-TERMINAL))
	 (RDFLiteral		  ::= (String (:OPT (:OR (LANGTAG-TERMINAL :RESULT #'(lambda (s) (create-rdf-literal-with-lang s (subseq $0 1))))
	   						 (^^-TERMINAL iri :RESULT #'(lambda (s) (create-rdf-literal-with-type s $1)))))
	   				      :RESULT (if (opt-yes-p $1) (funcall (opt-value $1) $0) $0)))
	 (BooleanLiteral	  ::= (:OR (TRUE-TERMINAL :RESULT t) (FALSE-TERMINAL :RESULT nil)))
	 (String		  ::= (:OR STRING_LITERAL_QUOTE-TERMINAL STRING_LITERAL_SINGLE_QUOTE-TERMINAL STRING_LITERAL_LONG_SINGLE_QUOTE-TERMINAL STRING_LITERAL_LONG_QUOTE-TERMINAL))
	 (iri			  ::= (:OR IRIREF-TERMINAL PrefixedName))
	 (PrefixedName            ::= (:OR PNAME_LN-TERMINAL (PNAME_NS-TERMINAL :RESULT (or (second $0) (parsing-failure "Unbound prefix ~A" (first $0))))))
	 (BlankNode		  ::= (:OR (BLANK_NODE_LABEL-TERMINAL :RESULT (make-rdf-blank-node $0)) (ANON-TERMINAL :RESULT (generate-rdf-blank-node)))))
	#'(lambda (lexer-func &rest keys &key &allow-other-keys)
	    (setf lexer lexer-func)
	    (init)
	    (apply #'turtle-parser lexer keys))))))

(defun parse-turtle-file (file &optional show-parse-p)
  (let ((*triple-count* 0)
	(*triple-sizes* 0))
    (time
     (let ((parser (make-turtle-parser)))
       (with-open-file (stream file)
	 (let ((lexer (make-turtle-lexer stream)))
	   (funcall parser lexer :show-parse-p show-parse-p)
	   (inform "~%triple-count = ~D, triple-sizes = ~D~%strings: ~D elems, prefixes: ~D elems, keywords: ~D elems"
		   *triple-count* *triple-sizes* (hash-table-count (lexer-string-table lexer)) (hash-table-count (lexer-prefix-table lexer)) (hash-table-count (lexer-keyword-table lexer)))))))))

