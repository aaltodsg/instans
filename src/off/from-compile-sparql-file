(defun run-syntax-tests (rules test-root-directory test-root-uri test-sets)
  (setf rules (concatenate 'string "file://" (namestring (probe-file rules))))
  (let* ((root-iri-string (let ((path (probe-file test-root-directory)))
			    (cond ((and path (null (pathname-name path)))
				   (when (member test-sets '(t :all))
				     (setf test-sets (test-root-subdir-names test-root-directory)))
				   (concatenate 'string "file://" (namestring path)))
				  (t
				   (format t "~&NOTE! Sparql test data directory not found in ~A" test-root-directory)
				   (format t "~&      If you want the tests run faster, download file")
				   (format t "~&      ~A.tar.gz" test-root-uri)
				   (format t "~&      and extract directory test-suite-archive/data-r2/ into ~A" test-root-uri)
				   (format t "~&      Using ~A instead" test-root-uri)
				   test-root-uri))))
	 (output-dir (or (let ((path (probe-file "../tests/output")))
			   (and path (string= (namestring path) (directory-namestring path)) (namestring path)))
			 (progn
			   (format t "~&NOTE! The output directory ../tests/output does not exist.")
			   (format t "~&      Create it if you want to have an HTML page showing the RETE network")
			   nil))))
    (loop for name in test-sets
	  for base-iri-string = (format nil "~A~A/" root-iri-string name)
	  for manifest-iri-string = (format nil "~A/manifest.ttl" base-iri-string)
	  do (cond ((not (file-or-uri-exists-p manifest-iri-string))
		    (format t "~&Manifest file ~A not found~&" manifest-iri-string))
		   (t
		    (format t "~&Running tests ~A~&" name)
		    (instans-execute-system rules :triples (parse-iri manifest-iri-string) :base (parse-iri base-iri-string)))))))

(defun run-data-r2-syntax-tests (&optional (test-sets '("syntax-sparql1" "syntax-sparql2" "syntax-sparql3" "syntax-sparql4" "syntax-sparql5")))
  (run-syntax-tests "../tests/input/syntax-test.rq" "../tests/data-r2" "http://www.w3.org/2001/sw/DataAccess/tests/data-r2" test-sets))

(defun run-data-sparql11-syntax-tests (&optional (test-sets '("syntax-query" "syntax-update-1" "syntax-update-2")))
  (run-syntax-tests "../tests/input/syntax-test.rq" "../tests/data-sparql11" "http://www.w3.org/2009/sparql/docs/tests/data-sparql11" test-sets))

(defun run-all-syntax-tests ()
  (run-syntax-tests "../tests/input/syntax-test.rq" "../tests/data-r2" "http://www.w3.org/2001/sw/DataAccess/tests/data-r2" t)
  (run-syntax-tests "../tests/input/syntax-test.rq" "../tests/data-sparql11" "http://www.w3.org/2009/sparql/docs/tests/data-sparql11" t))

;; (defun run-all-syntax-tests ()
;;   (sparql-call "instans:execute_system" "/Users/enu/instans/tests/input/syntax-test-runner.rq" )

					;(progn (untrace) (trace rete-add token-value make-token add-token remove-token add-alpha-token remove-alpha-token add-beta-token remove-beta-token))
(defun instans-add-triples (instans-iri input &key expected-results graph base subscribe)
  (when (debugp subscribe :parse-triples :execute)
    (inform "instans-add-triples ~S ~S :graph ~S :base ~S :subscribe ~S" instans-iri input graph base subscribe))
  (let* ((instans (get-instans instans-iri))
	 (comparep (and expected-results (not (rdf-iri-equal expected-results *rdf-nil*))))
	 (expected-query-results (if comparep (if (stringp expected-results) (parse-results-file instans expected-results) (parse-results-from-url instans expected-results))))
	 (expected-result-list (if comparep (sparql-query-results-results expected-query-results)))
	 (observed-result-list (list nil))
	 (observed-result-list-tail observed-result-list)
	 (compare-function (if comparep #'(lambda (node token)
	 				    (let ((solution (make-instance 'sparql-result
	 								   :bindings (loop for canonic-var in (node-use (node-prev node))
	 										for var = (reverse-resolve-binding instans canonic-var)
	 										collect (make-instance 'sparql-binding :variable var :value (token-value node token canonic-var))))))
	 				      (inform "Node ~S, (node-use (node-prev node)) ~S, token ~S, solution ~S" node (node-use (node-prev node)) token solution)
	 				      (setf (cdr observed-result-list-tail) (list solution))
	 				      (setf observed-result-list-tail (cdr observed-result-list-tail))))))
	 (observed-query-results (make-instance 'sparql-query-results))
	 (string (stream-contents-to-string (create-input-stream input))))
    (when compare-function
      (setf (instans-select-compare-function instans) compare-function))
    (with-input-from-string (triples-stream string)
      (let ((triples-parser (make-turtle-parser instans triples-stream :base base :subscribe subscribe
						:triples-block-callback #'(lambda (triples)
									    (when (debugp subscribe :execute)
									      (inform "~%Event callback: ~D triples~%" (length triples))
									      (loop for tr in triples do (inform " ~S~%" tr)))
									    (process-triple-input instans triples :ops '(:add :execute) :graph (if (and graph (rdf-iri-equal graph *rdf-nil*)) nil graph))))))
	(when (debugp subscribe :execute :parse-triples)
	  (inform "~%Processing triples:~%"))
	;; Is this OK?
;	(initialize-execution instans)
	(parse triples-parser)
	(unless (ll-parser-succeeded-p triples-parser)
	  (inform "~A:~A" input (instans-error-message instans)))
	(report-execution-status instans)
	(pop observed-result-list)
	(when (debugp subscribe :execute)
	  (inform "Expected-results ~S" expected-results)
	  (inform "Expected ~S" expected-result-list)
	  (inform "Observed-result-list ~S~%Observed-query-results ~S" observed-result-list observed-query-results))
	(when (debugp subscribe :execute)
	  ;; (sparql-query-results-to-json instans observed-query-results)
	  (when comparep
	    (sparql-query-results-to-json instans expected-query-results)))
	(setf (sparql-query-results-variables observed-query-results)
	      (loop with vars = nil
		 for result in observed-result-list
		 do (setf vars (union vars (mapcar #'sparql-binding-variable (sparql-result-bindings result))))
		 finally (return vars)))
	(setf (sparql-query-results-results observed-query-results) observed-result-list)
	(multiple-value-bind (similarp same-order-p)
	    (cond ((null comparep) (values t t))
		  (t
		   (sparql-results-compare expected-query-results observed-query-results :verbosep t :result-label1 "expected" :result-label2 "observed")))
	  (values similarp same-order-p instans))))))