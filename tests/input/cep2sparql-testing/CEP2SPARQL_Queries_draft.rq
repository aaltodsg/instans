# PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX :<http:example.org/default#>
PREFIX geo:<http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX ssn:<http://purl.oclc.org/NET/ssnx/ssn#>
PREFIX ep:<http://www.ontologydesignpatterns.org/cp/owl/eventprocessing.owl#>
PREFIX omgeo: <http://www.ontotext.com/owlim/geo#>
PREFIX ff: <http://factforge.net/>
PREFIX ex: <http://example.org/>
PREFIX time: <http://www.w3.org/2006/time#>

# Q0: Move everything from default graph to source
# MJR: Could be removed if known, how to access the default only without all the named contexts?

INSERT { GRAPH <http://example.org/source/> {
      ?sub ?pred ?obj } }
WHERE { ?sub ?pred ?obj }

# Semicolon separates queries in INSTANS
;

# Q1: Stateless filter: Only events generated during business hours
INSERT { GRAPH <http://example.org/poststateless/> {
      ?event ?p1 ?o1 .
      ?h2 ?p2 ?o2 } }
WHERE {  GRAPH <http://example.org/source/> {
    ?event a ep:EventObject ;
           ?p1 ?o1 ;
           ep:hasEventObjectSamplingTime ?time .
           OPTIONAL { BIND ( IF (isBlank(?o1), ?o1, 0) as ?h2)
                  ?h2 ?p2 ?o2 }
    FILTER ( ( HOURS(?time) > 8 ) && ( HOURS(?time) < 17 ) ) } }

;

# Q2: Only 1 event per hour
# Starts replicating memory (prevHour) entries in Sesame. A bug in Sesame handling OPTIONAL or something else?

DELETE { GRAPH <http://example.org/memory/> { 
    ?mem :prevHour ?prevhour } }
INSERT { GRAPH <http://example.org/poststateful/> {
      ?event ?p1 ?o1 .
      ?h2 ?p2 ?o2 }
 GRAPH <http://example.org/memory/> { 
     [] :prevHour ?hour }  
}
WHERE { GRAPH <http://example.org/poststateless/> {
    ?event a ep:EventObject ;
           ?p1 ?o1 ;
           ep:hasEventObjectSamplingTime ?time .
    OPTIONAL { BIND ( IF (isBlank(?o1), ?o1, 0) as ?h2)
            ?h2 ?p2 ?o2 }
    }
   GRAPH <http://example.org/memory/> {
    OPTIONAL  { ?mem :prevHour ?prevhour }
  }
  BIND ( HOURS(?time) as ?hour)
  FILTER ( ?hour != COALESCE(?prevhour,-1) ) 
}

;

# Q3: Enrich events with the name of the closest location
# Currently gets stuck in Sesame for an unknown reason
# Meanwhile, use test 2 below

PREFIX :<http:example.org/default#>
PREFIX geo:<http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX ssn:<http://purl.oclc.org/NET/ssnx/ssn#>
PREFIX ep:<http://www.ontologydesignpatterns.org/cp/owl/eventprocessing.owl#>
PREFIX omgeo: <http://www.ontotext.com/owlim/geo#>
PREFIX ff: <http://factforge.net/>

WITH <http://example.org/poststateful/>
INSERT { ?event :locationName ?label }
WHERE { 
    ?event a ep:EventObject ;
    geo:Point [ geo:lat ?lat ; geo:long ?long ; ] .
    SERVICE <http://factforge.net/sparql> {
       ?location omgeo:nearby(?lat ?long "1km"); 
                 ff:preferredLabel ?label } }
 

# Q3 Test query 1:
# Find anything near my coordinates
PREFIX omgeo: <http://www.ontotext.com/owlim/geo#>
PREFIX ff: <http://factforge.net/>

SELECT ?label
WHERE {
    SERVICE <http://factforge.net/sparql> {
        ?geolocation omgeo:nearby(60.158776 24.881490 "1km");
                 ff:preferredLabel ?label .
} }
LIMIT 1

# Q3 Test update 2:
PREFIX :<http:example.org/default#>
PREFIX geo:<http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX ssn:<http://purl.oclc.org/NET/ssnx/ssn#>
PREFIX ep:<http://www.ontologydesignpatterns.org/cp/owl/eventprocessing.owl#>
PREFIX omgeo: <http://www.ontotext.com/owlim/geo#>
PREFIX ff: <http://factforge.net/>

WITH <http://example.org/poststateful/>
INSERT {
   ?event :locationName ?label . }
WHERE { 
    ?event a ep:EventObject ;
    geo:Point [ geo:lat ?lat ; geo:long ?long ; ] .
    BIND ( "Espoo" as ?label )
  }

# Q3 Test query 3:
PREFIX :<http:example.org/default#>
PREFIX geo:<http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX ssn:<http://purl.oclc.org/NET/ssnx/ssn#>
PREFIX ep:<http://www.ontologydesignpatterns.org/cp/owl/eventprocessing.owl#>
PREFIX omgeo: <http://www.ontotext.com/owlim/geo#>
PREFIX ff: <http://factforge.net/>
PREFIX ex: <http://example.org/>

BASE <http://example.org/poststateful/>
SELECT *
WHERE { 
    ?event a ep:EventObject ;
    geo:Point [ geo:lat ?lat ; geo:long ?long ; ] .
    BIND ( "Espoo" as ?label )
  }

# Q3 Test query 4:
PREFIX :<http:example.org/default#>
PREFIX geo:<http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX ssn:<http://purl.oclc.org/NET/ssnx/ssn#>
PREFIX ep:<http://www.ontologydesignpatterns.org/cp/owl/eventprocessing.owl#>
PREFIX omgeo: <http://www.ontotext.com/owlim/geo#>
PREFIX ff: <http://factforge.net/>
PREFIX ex: <http://example.org/>

BASE <http://example.org/poststateful/>
SELECT *
WHERE { 
    ?event a ep:EventObject ;
    geo:Point [ geo:lat ?lat ; geo:long ?long ; ] .
    SERVICE <http://factforge.net/sparql> {
        ?geolocation omgeo:nearby(60.158776 24.881490 "1km");
                 ff:preferredLabel ?label . }
  }

# Q4 Project: Delete information from the incoming events

WITH <http://example.org/poststateful/>
DELETE {
  ?event :locationName ?label }
WHERE { 
    ?event a ep:EventObject ;
           :locationName ?label }

;

# Q5 Split: Create separate time and location events to the same channel (postsplit) using BIND
# DOESN'T WORK WITH events IDENTIFIED WITH BLANK NODES!

INSERT { GRAPH <http://example.org/postsplit/> {
    ?locationevent a ep:EventObject ;
           ssn:Sensor ?sensor ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] .
    ?timeevent a ep:EventObject ;
           ssn:Sensor ?sensor ;
           ep:hasEventObjectSamplingTime ?time } }
WHERE { GRAPH <http://example.org/poststateful/> {
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] ;
           ep:hasEventObjectSamplingTime ?time .
    BIND (IRI(concat(str(?event), "#location")) as ?locationevent)
    BIND (IRI(concat(str(?event), "#time")) as ?timeevent) } }

;

# Q5 Split v2: Create separate time and location events to the same channel (postsplit) using blank nodes

INSERT { GRAPH <http://example.org/postsplit/> {
    [] a ep:EventObject ;
           ssn:Sensor ?sensor ;
           :eventType :geoEvent ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] .
    [] a ep:EventObject ;
           ssn:Sensor ?sensor ;
           :eventType :timeEvent ;
           ep:hasEventObjectSamplingTime ?time } }
WHERE { GRAPH <http://example.org/poststateful/> {
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] ;
           ep:hasEventObjectSamplingTime ?time } }

;

# Q5 Split v3 (OFFICIAL): Split into separate channels using original blank nodes.
# Changed into this in order to demonstrate "Compose" (combine) later

INSERT { GRAPH <http://example.org/geoevents/> {
    ?event a ep:EventObject ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] }
  GRAPH <http://example.org/timeevents/> {
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
           ep:hasEventObjectSamplingTime ?time } }
WHERE { GRAPH <http://example.org/poststateful/> {
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] ;
           ep:hasEventObjectSamplingTime ?time } }

# Q6 Aggregate: Create new events out of the number of events observed in each hour
# This time use the original events to get a bit more to compute on

INSERT { GRAPH <http://example.org/eventcounts/> {
   [] a ep:EventObject ;
      :eventType :eventCount ;
      :hour ?hour ;
      :count ?nrevent } }
WHERE { 
  SELECT ?hour (COUNT(?event) as ?nrevent)
  WHERE { GRAPH <http://example.org/source/> {
      ?event a ep:EventObject ;
             ep:hasEventObjectSamplingTime ?time .
      BIND ( HOURS(?time) as ?hour ) } }
  GROUP BY ?hour }

;

# Q7 Compose: Combine two event streams into one

INSERT { GRAPH <http://example.org/combined/> {
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] ;
           ep:hasEventObjectSamplingTime ?time } }
WHERE { 
GRAPH <http://example.org/geoevents/> {
    ?event a ep:EventObject ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] }
  GRAPH <http://example.org/timeevents/> {
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
           ep:hasEventObjectSamplingTime ?time } }

;

# Q8a Pattern A: Create directional events

DELETE {  GRAPH <http://example.org/memory/> {
  ?mem ssn:Sensor ?sensor ;
       :prevLat ?prevlat ;
       :prevLong ?prevlong } }
INSERT { GRAPH <http://example.org/memory/> {
    [] ssn:Sensor ?sensor ;
       :prevLat ?lat ;
       :prevLong ?long  }
  GRAPH <http://example.org/directions/> {
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
	   :direction ?dir } }
WHERE { GRAPH <http://example.org/source/> {
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] . } 
  GRAPH <http://example.org/memory/> {
    OPTIONAL  { ?mem ssn:Sensor ?sensor ;
    	      	     :prevLat ?prevlat ;
                     :prevLong ?prevlong  }
      BIND ( IF ( ?lat > ?prevlat, "N", "") as ?latdir1)
      BIND ( IF ( ?lat < ?prevlat, "S", "") as ?latdir2)
      BIND ( IF ( ?long > ?prevlong, "E", "") as ?longdir1)
      BIND ( IF ( ?long < ?prevlong, "W", "") as ?longdir2) 
      BIND ( concat(?latdir1, ?latdir2, ?longdir1, ?longdir2) as ?dir )
} }

;

# Q8b Pattern B: Compare incoming pattern with pattern in database, advance index in memory if a match

DELETE {  GRAPH <http://example.org/memory/> {
  ?mem :patternindex ?memindex } }
INSERT { GRAPH <http://example.org/memory/> {
    [] :patternindex ?newindex } }
WHERE { GRAPH <http://example.org/directions/> {
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
	   :direction ?dir }
  GRAPH <http://example.org/memory/> {
    OPTIONAL  { ?mem :patternindex ?memindex } }
  GRAPH <http://example.org/pattern/> {
    ?pattern :index ?ptindex ;
             :value ?ptvalue }
  BIND ( COALESCE(?memindex+1,1) as ?newindex ) # COALESCE in case ?memindex not bound
  FILTER ( (?dir = ?ptvalue) && (?newindex = ?ptindex) )
}

;

# Q8c Pattern C: Reset index if the latest event does not match

DELETE {  GRAPH <http://example.org/memory/> {
  ?mem :patternindex ?memindex } }
WHERE { GRAPH <http://example.org/directions/> {
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
	   :direction ?dir }
  GRAPH <http://example.org/memory/> {
    ?mem :patternindex ?memindex }
  GRAPH <http://example.org/pattern/> {
    ?pattern :index ?ptindex ;
             :value ?ptvalue }
  FILTER ( (?dir != ?ptvalue) && (?memindex+1 = ?ptindex) )
}

;

# Q8d Pattern D: Insert an event into "patterndetect" channel, when the designated pattern is detected. Reset pattern index.

DELETE {  GRAPH <http://example.org/memory/> {
  ?mem :patternindex ?memindex } }
INSERT { GRAPH <http://example.org/patterndetect/> {
    [] a ep:EventObject ;
       :patterndetected "BackAndForth!" } }
WHERE { GRAPH <http://example.org/memory/> {
    ?mem :patternindex ?memindex }
    FILTER ( ?memindex = 2 )
}
