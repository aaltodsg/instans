;;; -*- Mode: Lisp; Syntax: COMMON-LISP; Base: 10; Package: INSTANS -*-
;;;
;;; Author: Esko Nuutila (esko.nuutila@aalto.fi)
;;;

(in-package #:instans)

(defmacro define-triple-parser (creator-function input-type)
  (unless (member input-type '(:trig :turtle)) (error* "Unknown triple input type ~S" input-type))
  `(defun ,creator-function (instans input-stream &key base subscribe triple-callback triples-callback ,@(if (eq input-type :trig) '(block-callback)))
     (when (null base) (setf base (parse-iri "http://")))
     (let* ((lexer (make-instance ',(case input-type (:trig 'trig-lexer) (:turtle 'turtle-lexer))
				  :input-stream input-stream :instans instans :base base :show-parses-p subscribe))
	    (current-subject nil)
	    (current-predicate nil)
	    (saved-subject nil)
	    (saved-predicate nil)
	    ,@(if (eq input-type :trig)
		  '((current-graph nil)))
	    (triples (list nil))
	    (triples-last triples)
	    (parser nil))
       (labels ((set-prefix (prefix-binding expansion) (rebind-prefix lexer prefix-binding expansion))
		(set-base (b) (set-lexer-base lexer b) (values))
		(pname2iri (prefix-binding suffix-string)
		  (or (pname-to-iri lexer prefix-binding suffix-string) (ll-parser-failure "Cannot transform ~A and ~A to an IRI" prefix-binding suffix-string)))
		(make-blank (name) (make-rdf-blank-node instans name))
		(generate-blank () (generate-rdf-blank-node instans))
		(clear-triples ()
		  (setf triples (list nil))
		  (setf triples-last triples))
		(get-triples ()
		  (prog1 (cdr triples)
		    (clear-triples)))
		(save-state () (setf saved-subject current-subject saved-predicate current-predicate) (values))
		(restore-state () (setf current-subject saved-subject current-predicate saved-predicate) (values))
		(set-subject (s) (setf current-subject s))
		(set-predicate (p) (setf current-predicate p))
		,@(if (eq input-type :trig) '((set-graph (g) (setf current-graph g))))
		(emit-current (current-object) (emit current-subject current-predicate current-object))
		(emit (s p o)
		  (incf *triple-count*)
		  (incf *triple-sizes* (+ (term-size s) (term-size p) (term-size o)))
					;	       (inform "emit ~S ~S ~S" s p o)
		  (setf (cdr triples-last) (list (list s p o)))
		  (setf triples-last (cdr triples-last))
		  (when triple-callback (funcall triple-callback s p o)))
		;; (emit-subj-pred-obj-list (s pol)
		;; 			;	       (inform "emit-subj-pred-obj-list ~S ~S" s pol)
		;;   (loop for (p . ol) in pol do (loop for o in ol do (emit s p o)))
		;;   s)
		;; (expand-collection (col)
		;;   (cond ((null col) *rdf-nil*)
		;; 	(t
		;; 	 (let ((subj (generate-blank))
		;; 	       (rest (expand-collection (cdr col))))
		;; 	   (emit subj *rdf-rest* rest)
		;; 	   (emit subj *rdf-first* (car col))
		;; 	   subj))))
		)
	 (setf parser
	       (generate-ll1-parser triple
		 ,@(if (eq input-type :trig)
		       '((trigDoc	     ::= ((:REP0 (:OR directive block)) :RESULT (values)))
			 (block		     ::= ((:OR triplesOrGraph
						       ((:RESULT (set-graph nil)) wrappedGraph)
						       ((:RESULT (set-graph nil)) triples2)
						       (GRAPH-TERMINAL labelOrSubject wrappedGraph))
						  :RESULT (progn (when block-callback (funcall block-callback current-graph (get-triples))) (values))))
			 (triplesOrGraph     ::= (labelOrSubject (:OR wrappedGraph ((:RESULT (set-graph nil)) predicateObjectList .-TERMINAL))))
			 (triples2           ::= (:OR (blankNodePropertyList (:OPT predicateObjectList) .-TERMINAL) (collection predicateObjectList .-TERMINAL)))
			 (wrappedGraph       ::= (|{-TERMINAL| (:OPT triplesBlock) |}-TERMINAL|))
			 (triplesBlock       ::= (triples (:OPT .-TERMINAL (:OPT triplesBlock))))
			 (labelOrSubject     ::= (:OR iri BlankNode) :RESULT (progn (set-graph $0) (set-subject $0)))
			 (blank		     ::= (:OR BlankNode collection)))
		       '((turtleDoc	     ::= ((:REP0 statement) :RESULT (values)))
			 (statement	     ::= (:OR directive (triples .-TERMINAL :RESULT (values))))))
		 (directive	             ::= (:OR prefixID base sparqlPrefix sparqlBase) :RESULT (values))
		 (prefixID		     ::= (@PREFIX-TERMINAL PNAME_NS-TERMINAL IRIREF-TERMINAL .-TERMINAL :RESULT (set-prefix $1 $2)))
		 (base		             ::= (@BASE-TERMINAL (IRIREF-TERMINAL :RESULT (progn (set-base $0))) .-TERMINAL))
		 (sparqlBase	             ::= (BASE-TERMINAL IRIREF-TERMINAL :RESULT (set-base $1)))
		 (sparqlPrefix	             ::= (PREFIX-TERMINAL PNAME_NS-TERMINAL IRIREF-TERMINAL :RESULT (set-prefix $1 $2)))
		 (triples		     ::= (:OR (subject predicateObjectList)
						      (blankNodePropertyList (:OPT predicateObjectList)))
					              :RESULT (progn (when triples-callback (funcall triples-callback (get-triples))) (values)))
		 (predicateObjectList        ::= ((verb objectList :RESULT (cons $0 $1))
						  (:REP0 (|;-TERMINAL| (:OPT (verb objectList :RESULT (list (cons $0 $1)))) :RESULT (opt-value $1))))
					          :RESULT (cons $0 (apply #'append $1)))
		 (objectList	             ::= (object (:REP0 (|,-TERMINAL| object :RESULT $1)) :RESULT (cons $0 $1)))
		 (verb		             ::= (:OR predicate (A-TERMINAL :RESULT *rdf-type*)) :RESULT (set-predicate $0))
		 (subject		     ::= (:OR iri BlankNode collection) :RESULT (set-subject $0))
		 (predicate	             ::= (iri))
		 (object		     ::= (:OR iri BlankNode collection blankNodePropertyList literal) :RESULT (progn (emit-current $0) (values)))
		 (literal		     ::= (:OR RDFLiteral NumericLiteral BooleanLiteral))
		 (blankNodePropertyList      ::= ([-TERMINAL
						  (:RESULT (let ((b (generate-blank)))
							     (save-state)
							     (set-subject b)
							     b))
						  predicateObjectList
						  ]-TERMINAL
						  :RESULT (progn (restore-state) $1)))
		 (collection	             ::= (|(-TERMINAL|
						  (:OR (:RESULT *rdf-nil*)
						       ((:RESULT (let ((b (generate-blank)))
								   (save-state)
								   (set-subject b)
								   (set-predicate *rdf-first*)
								   b))
							object
							(:REP0 ((:RESULT (let ((b (generate-blank)))
									   (set-predicate *rdf-rest*)
									   (emit-current b)
									   (set-subject b)
									   (set-predicate *rdf-first*)))
								object))
							:RESULT (progn (set-predicate *rdf-rest*) (emit-current *rdf-nil*) (restore-state) $0)))
						  |)-TERMINAL| :RESULT $1))
		 (NumericLiteral	     ::= (:OR INTEGER-TERMINAL DECIMAL-TERMINAL DOUBLE-TERMINAL))
		 (RDFLiteral	             ::= (String (:OPT (:OR (LANGTAG-TERMINAL :RESULT #'(lambda (s) (create-rdf-literal-with-lang s (subseq $0 1))))
								    (^^-TERMINAL iri :RESULT #'(lambda (s) (nth-value 0 (create-rdf-literal-with-type s $1))))))
						 :RESULT (if (opt-yes-p $1) (funcall (opt-value $1) $0) $0)))
		 (BooleanLiteral	     ::= (:OR (TRUE-TERMINAL :RESULT t) (FALSE-TERMINAL :RESULT nil)))
		 (String		     ::= (:OR STRING_LITERAL_QUOTE-TERMINAL STRING_LITERAL_SINGLE_QUOTE-TERMINAL
						      STRING_LITERAL_LONG_SINGLE_QUOTE-TERMINAL STRING_LITERAL_LONG_QUOTE-TERMINAL))
		 (iri		             ::= (:OR IRIREF-TERMINAL PrefixedName))
		 (PrefixedName	             ::= (:OR (PNAME_LN-TERMINAL :RESULT (pname2iri (first $0) (second $0)))
						      (PNAME_NS-TERMINAL :RESULT (or (second $0) (ll-parser-failure "Unbound prefix ~A" (first $0))))))
		 (BlankNode	             ::= (:OR (BLANK_NODE_LABEL-TERMINAL :RESULT (make-blank $0)) (ANON-TERMINAL :RESULT (generate-blank))))))
	 (setf (ll-parser-lexer parser) lexer)
	 (setf (ll-parser-subscribe parser) subscribe)
	 parser))))

;; (defmacro define-triple-parser (creator-function input-type)
;;   (unless (member input-type '(:trig :turtle)) (error* "Unknown triple input type ~S" input-type))
;;   `(defun ,creator-function (instans input-stream &key base subscribe triple-callback triples-block-callback)
;;      (when (null base) (setf base (parse-iri "http://")))
;;      (let* ((lexer (make-instance ',(case input-type (:trig 'trig-lexer) (:turtle 'turtle-lexer))
;; 				  :input-stream input-stream :instans instans :base base :show-parses-p subscribe))
;; 	    (triples (list nil))
;; 	    (triples-last triples)
;; 	    (parser nil))
;;        (labels ((set-prefix (prefix-binding expansion) (rebind-prefix lexer prefix-binding expansion))
;; 		(set-base (b) (set-lexer-base lexer b) (values))
;; 		(pname2iri (prefix-binding suffix-string)
;; 		  (or (pname-to-iri lexer prefix-binding suffix-string) (ll-parser-failure "Cannot transform ~A and ~A to an IRI" prefix-binding suffix-string)))
;; 		(make-blank (name) (make-rdf-blank-node instans name))
;; 		(generate-blank () (generate-rdf-blank-node instans))
;; 		(clear-triples ()
;; 		  (setf triples (list nil))
;; 		  (setf triples-last triples))
;; 		(get-triples ()
;; 		  (prog1 (cdr triples)
;; 		    (clear-triples)))
;; 		(emit (s p o)
;; 		  (incf *triple-count*)
;; 		  (incf *triple-sizes* (+ (term-size s) (term-size p) (term-size o)))
;; 					;	       (inform "emit ~S ~S ~S" s p o)
;; 		  (setf (cdr triples-last) (list (list s p o)))
;; 		  (setf triples-last (cdr triples-last))
;; 		  (when triple-callback (funcall triple-callback s p o)))
;; 		(emit-subj-pred-obj-list (s pol)
;; 					;	       (inform "emit-subj-pred-obj-list ~S ~S" s pol)
;; 		  (loop for (p . ol) in pol do (loop for o in ol do (emit s p o)))
;; 		  s)
;; 		(expand-collection (col)
;; 		  (cond ((null col) *rdf-nil*)
;; 			(t
;; 			 (let ((subj (generate-blank))
;; 			       (rest (expand-collection (cdr col))))
;; 			   (emit subj *rdf-rest* rest)
;; 			   (emit subj *rdf-first* (car col))
;; 			   subj)))))
;; 	 (setf parser
;; 	       (generate-ll1-parser triple
;; 		 ,@(if (eq input-type :trig)
;; 		       '((trigDoc	     ::= ((:REP0 (:OR directive block)) :RESULT (values)))
;; 			 (block		     ::= (:OR triplesOrGraph wrappedGraph triples2 (GRAPH-TERMINAL labelOrSubject wrappedGraph)))
;; 			 (triplesOrGraph     ::= (labelOrSubject (:OR wrappedGraph (predicateObjectList .-TERMINAL))))
;; 			 (triples2           ::= (:OR (blankNodePropertyList (:OPT predicateObjectList) .-TERMINAL) (collection predicateObjectList .-TERMINAL)))
;; 			 (wrappedGraph       ::= (|{-TERMINAL| (:OPT triplesBlock) |}-TERMINAL|))
;; 			 (triplesBlock       ::= (triples (:OPT .-TERMINAL (:OPT triplesBlock))))
;; 			 (labelOrSubject     ::= (:OR iri BlankNode))
;; 			 (blank		     ::= (:OR BlankNode collection)))
;; 		       '((turtleDoc	     ::= ((:REP0 statement) :RESULT (values)))
;; 			 (statement	     ::= (:OR directive (triples .-TERMINAL :RESULT (values))))))
;; 		 (directive	             ::= (:OR prefixID base sparqlPrefix sparqlBase) :RESULT (values))
;; 		 (prefixID		     ::= (@PREFIX-TERMINAL PNAME_NS-TERMINAL IRIREF-TERMINAL .-TERMINAL :RESULT (set-prefix $1 $2)))
;; 		 (base		             ::= (@BASE-TERMINAL (IRIREF-TERMINAL :RESULT (progn (set-base $0))) .-TERMINAL))
;; 		 (sparqlBase	             ::= (BASE-TERMINAL IRIREF-TERMINAL :RESULT (set-base $1)))
;; 		 (sparqlPrefix	             ::= (PREFIX-TERMINAL PNAME_NS-TERMINAL IRIREF-TERMINAL :RESULT (set-prefix $1 $2)))
;; 		 (triples		     ::= (:OR (subject predicateObjectList :RESULT (emit-subj-pred-obj-list $0 $1))
;; 						      (blankNodePropertyList (:OPT predicateObjectList) :RESULT (emit-subj-pred-obj-list $0 (opt-value $1))))
;; 					              :RESULT (progn (when triples-block-callback (funcall triples-block-callback (get-triples))) (values)))
;; 		 (predicateObjectList        ::= ((verb objectList :RESULT (cons $0 $1))
;; 						  (:REP0 (|;-TERMINAL| (:OPT (verb objectList :RESULT (list (cons $0 $1)))) :RESULT (opt-value $1))))
;; 					          :RESULT (cons $0 (apply #'append $1)))
;; 		 (objectList	             ::= (object (:REP0 (|,-TERMINAL| object :RESULT $1)) :RESULT (cons $0 $1)))
;; 		 (verb		             ::= (:OR predicate (A-TERMINAL :RESULT *rdf-type*)))
;; 		 (subject		     ::= (:OR iri BlankNode collection))
;; 		 (predicate	             ::= (iri))
;; 		 (object		     ::= (:OR iri BlankNode collection blankNodePropertyList literal))
;; 		 (literal		     ::= (:OR RDFLiteral NumericLiteral BooleanLiteral))
;; 		 (blankNodePropertyList      ::= ([-TERMINAL predicateObjectList ]-TERMINAL :RESULT (emit-subj-pred-obj-list (generate-blank) $1)))
;; 		 (collection	             ::= (|(-TERMINAL| (:REP0 object) |)-TERMINAL|) :RESULT (expand-collection $1))
;; 		 (NumericLiteral	     ::= (:OR INTEGER-TERMINAL DECIMAL-TERMINAL DOUBLE-TERMINAL))
;; 		 (RDFLiteral	             ::= (String (:OPT (:OR (LANGTAG-TERMINAL :RESULT #'(lambda (s) (create-rdf-literal-with-lang s (subseq $0 1))))
;; 								    (^^-TERMINAL iri :RESULT #'(lambda (s) (nth-value 0 (create-rdf-literal-with-type s $1))))))
;; 						 :RESULT (if (opt-yes-p $1) (funcall (opt-value $1) $0) $0)))
;; 		 (BooleanLiteral	     ::= (:OR (TRUE-TERMINAL :RESULT t) (FALSE-TERMINAL :RESULT nil)))
;; 		 (String		     ::= (:OR STRING_LITERAL_QUOTE-TERMINAL STRING_LITERAL_SINGLE_QUOTE-TERMINAL
;; 						      STRING_LITERAL_LONG_SINGLE_QUOTE-TERMINAL STRING_LITERAL_LONG_QUOTE-TERMINAL))
;; 		 (iri		             ::= (:OR IRIREF-TERMINAL PrefixedName))
;; 		 (PrefixedName	             ::= (:OR (PNAME_LN-TERMINAL :RESULT (pname2iri (first $0) (second $0)))
;; 						      (PNAME_NS-TERMINAL :RESULT (or (second $0) (ll-parser-failure "Unbound prefix ~A" (first $0))))))
;; 		 (BlankNode	             ::= (:OR (BLANK_NODE_LABEL-TERMINAL :RESULT (make-blank $0)) (ANON-TERMINAL :RESULT (generate-blank))))))
;; 	 (setf (ll-parser-lexer parser) lexer)
;; 	 (setf (ll-parser-subscribe parser) subscribe)
;; 	 parser))))

(define-triple-parser make-turtle-parser2 :turtle)

(define-triple-parser make-trig-parser :trig)

