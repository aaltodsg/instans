BASE <http://instans.org/>
PREFIX :<http:instans.org/default#>
PREFIX geo:<http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX ssn:<http://purl.oclc.org/NET/ssnx/ssn#>
PREFIX ep:<http://www.ontologydesignpatterns.org/cp/owl/eventprocessing.owl#>
PREFIX omgeo: <http://www.ontotext.com/owlim/geo#>
PREFIX ff: <http://factforge.net/>

# Transform (auxiliary rule): Create directional events

DELETE {  GRAPH <memory> { # Delete previous memory entry
  ?mem ssn:Sensor ?sensor ;
       :prevLat ?prevlat ;
       :prevLong ?prevlong } }
INSERT { GRAPH <memory> { # Write new entry to memory
    [] ssn:Sensor ?sensor ;
       :prevLat ?lat ;
       :prevLong ?long  }
  GRAPH <directions> { # Output directional information
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
	   :direction ?dir } }
WHERE { GRAPH <source> {
    ?event a ep:EventObject ; # Match incoming events
           ssn:Sensor ?sensor ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] . } 
  OPTIONAL { GRAPH <memory> { # Retrieve coordinates of previous event from memory-graph
    ?mem ssn:Sensor ?sensor ;
    	 :prevLat ?prevlat ;
         :prevLong ?prevlong } }
  BIND ( IF ( ?lat > ?prevlat, "N", "") as ?latdir1) # Test for directions
  BIND ( IF ( ?lat < ?prevlat, "S", "") as ?latdir2)
  BIND ( IF ( ?long > ?prevlong, "E", "") as ?longdir1)
  BIND ( IF ( ?long < ?prevlong, "W", "") as ?longdir2) 
  BIND ( concat(?latdir1, ?latdir2, ?longdir1, ?longdir2) as ?tdir ) # Concatenate result
  BIND ( IF ( !bound(?tdir) || strlen(?tdir)=0, "0", ?tdir ) as ?dir )
} ;

# Pattern Detection (EPA 8-1): Compare incoming pattern with pattern in database, advance index in memory if a match

INSERT DATA { GRAPH <memory> {
  :pattern :patternindex 0 } } ;

DELETE {  GRAPH <memory> { # Clear old index from memory
    :pattern :patternindex ?memindex } }
INSERT { GRAPH <memory> { # Write new index to memory
    :pattern :patternindex ?newindex } }
WHERE { GRAPH <directions> {
    ?event a ep:EventObject ; # Match directional input
           ssn:Sensor ?sensor ;
	   :direction ?dir }
  FILTER ( ?dir != "0" )
  GRAPH <memory> { # Retrieve index from memory
      :pattern :patternindex ?memindex }
  GRAPH <pattern> { # Retrieve pattern index and value
    ?pattern :index ?ptindex ;
             :value ?ptvalue }
  BIND ( COALESCE(?memindex+1,1) as ?newindex ) # COALESCE in case ?memindex not bound
  FILTER ( (?dir = ?ptvalue) && (?newindex = ?ptindex) ) # Pass through if value and index match
} ;

# Pattern Detection (EPA 8-2): Reset index if the latest event does not match

#DELETE {  GRAPH <memory> { # Remove index from memory
#    :pattern :patternindex ?memindex } }
SELECT ?dir ?ptvalue ?memindex ?ptindex
WHERE { GRAPH <directions> { # Match directional input
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
	   :direction ?dir }
  FILTER ( ?dir != "0" )
  GRAPH <memory> { # Retrieve index from memory
    :pattern :patternindex ?memindex }
  GRAPH <pattern> {
    ?pattern :index ?ptindex ;
             :value ?ptvalue }
  FILTER ( (?dir != ?ptvalue) && (?memindex+1 = ?ptindex) ) # Pass through if value and index do not match
} ;

# Pattern Detection (EPA 8-3): Insert an event into "patterndetect" channel, when the designated pattern is detected. Reset pattern index.

DELETE {  GRAPH <memory> { # Remove index from memory
  :pattern :patternindex ?memindex } }
INSERT { # GRAPH <memory> { :pattern :patternindex 0 }
  GRAPH <patterndetect> { # Create an event object to announce pattern match
    [] a ep:EventObject ;
       :patterndetected "BackAndForth!" }
 }
WHERE { GRAPH <pattern> { :pattern :length ?length }
  GRAPH <memory> { # Check, when pattern index in memory matches pattern length.
    :pattern :patternindex ?memindex }
  FILTER ( ?memindex = ?length )
} ;

# Output everything

SELECT *
WHERE { GRAPH ?g { ?s ?p ?o } }

