PREFIX : <http:instans.org/default#>
PREFIX geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX ssn: <http://purl.oclc.org/NET/ssnx/ssn#>
PREFIX ep: <http://www.ontologydesignpatterns.org/cp/owl/eventprocessing.owl#>
PREFIX omgeo: <http://www.ontotext.com/owlim/geo#>
PREFIX ff: <http://factforge.net/>
BASE <http://example.org/>

# Stateless filter (EPA 1): Only events generated during business hours

INSERT { GRAPH <poststateless> {  # Forward outgoing events
      ?event ?p1 ?o1 .
      ?h2 ?p2 ?o2 } }
WHERE { GRAPH <source> {
    ?event a ep:EventObject ;    # Match incoming events
           ?p1 ?o1 ;
           ep:hasEventObjectSamplingTime ?time .
           OPTIONAL { BIND ( IF (isBlank(?o1), ?o1, 0) as ?h2)
                ?h2 ?p2 ?o2 }
    FILTER ( ( HOURS(?time) > 8 ) && ( HOURS(?time) < 17 ) ) } }

;

# Output everything

SELECT *
WHERE { GRAPH ?g { ?s ?p ?o }}

;

# Stateful filter (EPA 2): Only 1 event per hour

DELETE { GRAPH <memory> { # Clear memory
    ?mem :prevHour ?prevhour } }
INSERT { GRAPH <poststateful> { # Forward outgoing events
      ?event ?p1 ?o1 .
      ?h2 ?p2 ?o2
    }
 GRAPH <memory> { # Write new value to memory
     [] :prevHour ?hour }  
}
WHERE { GRAPH <poststateless> {
    ?event a ep:EventObject ; # Match incoming events
           ?p1 ?o1 ;
           ep:hasEventObjectSamplingTime ?time .
    OPTIONAL { BIND ( IF (isBlank(?o1), ?o1, 0) as ?h2)
            ?h2 ?p2 ?o2 }
    }
   GRAPH <memory> { # Retrieve value from memory, if available
    OPTIONAL  { ?mem :prevHour ?prevhour }
   }
  BIND ( HOURS(?time) as ?hour)
#  This filter gets stuck:
# FILTER ( COALESCE(?hour,-2) != COALESCE(?prevhour,-1) ) # Compare current with memory
}

;

# Enrich (EPA 3): Enrich events with the name of the closest location
# SERVICE-query replaced with BIND ( "Espoo" as ?label ) to avoid external lookup delay
# and because SERVICE is not yet implemented in INSTANS

INSERT { GRAPH <translated> { 
    ?event a ep:EventObject ; # Forward enriched event
         ssn:Sensor ?sensor ;
         geo:Point [ geo:lat ?lat ; geo:long ?long ; ] ;
         ep:hasEventObjectSamplingTime ?time ;
         :locationName ?label } }
WHERE { GRAPH <poststateful> { 
    ?event a ep:EventObject ; # Match incoming event
           ssn:Sensor ?sensor ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] ;
           ep:hasEventObjectSamplingTime ?time .
     BIND ( "Espoo" as ?label ) # Temporary replacement until SERVICE implemented
#    SERVICE <http://factforge.net/sparql> { # Retrieve location label
#       ?location omgeo:nearby(?lat ?long "1km"); 
#                 ff:preferredLabel ?label }
} }

; 

# Project (EPA 4): Delete information from the incoming events

INSERT {  GRAPH <projected> { 
    ?event a ep:EventObject ; # Forward projected event
         ssn:Sensor ?sensor ;
         geo:Point [ geo:lat ?lat ; geo:long ?long ; ] ;
         ep:hasEventObjectSamplingTime ?time } }
WHERE {  GRAPH <translated> { 
    ?event a ep:EventObject ; # Match wanted triples only
         ssn:Sensor ?sensor ;
         geo:Point [ geo:lat ?lat ; geo:long ?long ; ] ;
         ep:hasEventObjectSamplingTime ?time } }

;

# Split (EPA 5): Split into separate channels using original blank nodes.

INSERT { GRAPH <geoevents> { # Insert GeoEvents
    ?event a ep:EventObject ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] }
  GRAPH <timeevents> { # Insert TimeEvents
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
           ep:hasEventObjectSamplingTime ?time } }
WHERE { GRAPH <poststateful> { # Match incoming events
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] ;
           ep:hasEventObjectSamplingTime ?time } }

;

# Aggregate (EPA 6): Create new events out of the number of events observed in each hour

INSERT { GRAPH <eventcounts> {
   [] a ep:EventObject ; # Insert counter events
      :eventType :eventCount ;
      :hour ?hour ;
      :count ?nrevent } }
WHERE {
  {
  SELECT ?hour (COUNT(?event) as ?nrevent) # Count the number of events
  WHERE { GRAPH <source> {
      ?event a ep:EventObject ;
             ep:hasEventObjectSamplingTime ?time .
      BIND ( HOURS(?time) as ?hour ) } }
  GROUP BY ?hour } # Group results based on hour
}
;

# Compose (EPA 7): Combine two event streams into one

INSERT { GRAPH <combined> {
    ?event a ep:EventObject ; # Forward re-combined events
           ssn:Sensor ?sensor ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] ;
           ep:hasEventObjectSamplingTime ?time } }
WHERE { 
GRAPH <geoevents> { # Match GeoEvents
    ?event a ep:EventObject ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] }
  GRAPH <timeevents> { # Match TimeEvents
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
           ep:hasEventObjectSamplingTime ?time } }

;

# Transform (auxiliary rule): Create directional events

DELETE {  GRAPH <memory> { # Delete previous memory entry
  ?mem ssn:Sensor ?sensor ;
       :prevLat ?prevlat ;
       :prevLong ?prevlong } }
INSERT { GRAPH <memory> { # Write new entry to memory
    [] ssn:Sensor ?sensor ;
       :prevLat ?lat ;
       :prevLong ?long  }
  GRAPH <directions> { # Output directional information
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
	   :direction ?dir } }
WHERE { GRAPH <source> {
    ?event a ep:EventObject ; # Match incoming events
           ssn:Sensor ?sensor ;
           geo:Point [ geo:lat ?lat ; geo:long ?long ; ] . } 
  GRAPH <memory> { # Retrieve coordinates of previous event from memory-graph
    OPTIONAL  { ?mem ssn:Sensor ?sensor ;
    	      	     :prevLat ?prevlat ;
                     :prevLong ?prevlong  }
      BIND ( IF ( ?lat > ?prevlat, "N", "") as ?latdir1) # Test for directions
      BIND ( IF ( ?lat < ?prevlat, "S", "") as ?latdir2)
      BIND ( IF ( ?long > ?prevlong, "E", "") as ?longdir1)
      BIND ( IF ( ?long < ?prevlong, "W", "") as ?longdir2) 
      BIND ( concat(?latdir1, ?latdir2, ?longdir1, ?longdir2) as ?dir ) # Concatenate result
} }

;

# Pattern Detection (EPA 8-1): Compare incoming pattern with pattern in database, advance index in memory if a match

DELETE {  GRAPH <memory> { # Clear old index from memory
  ?mem :patternindex ?memindex } }
INSERT { GRAPH <memory> { # Write new index to memory
    [] :patternindex ?newindex } }
WHERE { GRAPH <directions> {
    ?event a ep:EventObject ; # Match directional input
           ssn:Sensor ?sensor ;
	   :direction ?dir }
  GRAPH <memory> { # Retrieve index from memory
    OPTIONAL  { ?mem :patternindex ?memindex } }
  GRAPH <pattern> { # Retrieve pattern index and value
    ?pattern :index ?ptindex ;
             :value ?ptvalue }
  BIND ( COALESCE(?memindex+1,1) as ?newindex ) # COALESCE in case ?memindex not bound
  FILTER ( (?dir = ?ptvalue) && (?newindex = ?ptindex) ) # Pass through if value and index match
}

;

# Pattern Detection (EPA 8-2): Reset index if the latest event does not match

DELETE {  GRAPH <memory> { # Remove index from memory
  ?mem :patternindex ?memindex } }
WHERE { GRAPH <directions> { # Match directional input
    ?event a ep:EventObject ;
           ssn:Sensor ?sensor ;
	   :direction ?dir }
  GRAPH <memory> { # Retrieve index from memory
    ?mem :patternindex ?memindex }
  GRAPH <pattern> {
    ?pattern :index ?ptindex ;
             :value ?ptvalue }
  FILTER ( (?dir != ?ptvalue) && (?memindex+1 = ?ptindex) ) # Pass through if value and index do not match
}

;

# Pattern Detection (EPA 8-3): Insert an event into "patterndetect" channel, when the designated pattern is detected. Reset pattern index.

DELETE {  GRAPH <memory> { # Remove index from memory
  ?mem :patternindex ?memindex } }
INSERT { GRAPH <patterndetect> { # Create an event object to announce pattern match
    [] a ep:EventObject ;
       :patterndetected "BackAndForth!" } }
WHERE { GRAPH <memory> { # Check, when pattern index in memory matches pattern length.
    ?mem :patternindex ?memindex }
    FILTER ( ?memindex = 2 ) # Instead of literal constant, also the pattern length could be saved to a graph as a parameter.
}
