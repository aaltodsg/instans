;; (defun parse-tests-from-csv (&key (csv-file "/Users/enu/instans/tests/sparql-tests/sparql-tests.csv"))
;;   (let ((key-field-names '("type" "suite" "collection" "name"))
;; 	(list-field-names '("graphfiles" "graphlabels" "resultgraphfiles" "resultgraphlabels")))
;;     (multiple-value-bind (alist headers); linecount entrycount)
;; 	(csv-file-to-alist csv-file
;; 			   :key-fields key-field-names
;; 			   :data-field-merge #'(lambda (field-key new-value old-value-or-values)
;; 						 (cond ((member field-key list-field-names :test #'equal)
;; 							(cond ((or (null new-value) (equal new-value "UNBOUND")) old-value-or-values)
;; 							      (t (append old-value-or-values (list new-value)))))
;; 						       ((or (null new-value) (equal new-value "UNBOUND")) old-value-or-values)
;; 						       ((or (null old-value-or-values) (equal old-value-or-values "UNBOUND")) new-value)
;; 						       ((equal new-value old-value-or-values) new-value)
;; 						       (t (error* "Two different values for non-list field ~A: ~A vs. ~A" field-key new-value old-value-or-values)))))
;;     ;; (loop for entry in alist
;;     ;; 	  for key = (first entry)
;;     ;; 	  for values = (second entry)
;;     ;; 	  for name-value-list = (mapcar #'list (nthcdr 4 headers) values)
;;     ;; 	  do (assert (null (cddr entry)))
;;     ;; 	  do (inform "~A ~{~A~^/~}:~{~%  ~{:~A~^ ~A~}~}" (first key) (rest key) name-value-list))
;;     ;; 					;    alist
;;       (flet ((test-type-class-name (type-string)
;; 	       (cond ((string= type-string "mf:PositiveSyntaxTest") 'sparql-positive-syntax-test)
;; 		     ((string= type-string "mf:NegativeSyntaxTest") 'sparql-negative-syntax-test)
;; 		     ((string= type-string "mf:PositiveSyntaxTest11") 'sparql-positive-syntax-test-11)
;; 		     ((string= type-string "mf:NegativeSyntaxTest11") 'sparql-negative-syntax-test-11)
;; 		     ((string= type-string "mf:PositiveUpdateSyntaxTest11") 'sparql-positive-update-syntax-test-11)
;; 		     ((string= type-string "mf:NegativeUpdateSyntaxTest11") 'sparql-negative-update-syntax-test-11)
;; 		     ((string= type-string "mf:QueryEvaluationTest") 'sparql-query-evaluation-test)
;; 		     ((string= type-string "mf:UpdateEvaluationTest") 'sparql-update-evaluation-test)
;; 		     ((string= type-string "mf:CSVResultFormatTest") 'sparql-csv-result-format-test)
;; 		     ((string= type-string "mf:ProtocolTest") 'sparql-protocol-test)
;; 		     ((string= type-string "mf:ServiceDescriptionTest") 'sparql-service-description-test)
;; 		     (t (error* "Unknown test type ~A" type-string)))))
;; 	(let ((header-keywords (mapcar #'(lambda (h) (intern-keyword (string-upcase h))) headers)))
;; 	  (make-instance 'sparql-tests2
;; 			 :fields header-keywords
;; 			 :entries (loop for entry in alist
;; 					for key = (first entry)
;; 					for values = (second entry)
;; 					for type-class-name = (test-type-class-name (first key))
;; 					for args = (append (list type-class-name :type (first key) :suite (second key) :collection (third key) :name (fourth key))
;; 							   (loop for keyword in (nthcdr 4 header-keywords)
;; 								 for value in values
;; 								 nconc (list keyword value)))
;; 					for test = (apply #'make-instance args)
;; 					when (equal (fourth key) "add01")
;; 					do (progn (inform "entry = ~S~%args = ~S" entry args) (describe test))
;; 					collect test)))))))

;; (add-sparql-test tests
;; 							     :type type :negative (parse-xsd-boolean negative) :suite suite :collection collection :name name
;; 							     :queryfile queryfile :datafile datafile :graphdatafile graphdatafile
;; 							     :resultfile resultfile :resultgraphfile resultgraphfile :resultgraphlabel resultgraphlabel)

;; (defun parse-tests-from-csv (&key (csv-file "/Users/enu/instans/tests/sparql-tests/sparql-tests.csv"))
;;   (let ((key-field-names '("type" "suite" "collection" "name"))
;; 	(list-field-names '("graphfiles" "graphlabels" "resultgraphfiles" "resultgraphlabels")))
;;     (multiple-value-bind (alist headers); linecount entrycount)
;; 	(csv-file-to-alist csv-file
;; 			   :key-fields key-field-names
;; 			   :data-field-merge #'(lambda (field-key new-value old-value-or-values)
;; 						 (cond ((member field-key list-field-names :test #'equal)
;; 							(cond ((or (null new-value) (equal new-value "UNBOUND")) old-value-or-values)
;; 							      (t (append old-value-or-values (list new-value)))))
;; 						       ((or (null new-value) (equal new-value "UNBOUND")) old-value-or-values)
;; 						       ((or (null old-value-or-values) (equal old-value-or-values "UNBOUND")) new-value)
;; 						       ((equal new-value old-value-or-values) new-value)
;; 						       (t (error* "Two different values for non-list field ~A: ~A vs. ~A" field-key new-value old-value-or-values)))))
;;     ;; (loop for entry in alist
;;     ;; 	  for key = (first entry)
;;     ;; 	  for values = (second entry)
;;     ;; 	  for name-value-list = (mapcar #'list (nthcdr 4 headers) values)
;;     ;; 	  do (assert (null (cddr entry)))
;;     ;; 	  do (inform "~A ~{~A~^/~}:~{~%  ~{:~A~^ ~A~}~}" (first key) (rest key) name-value-list))
;;     ;; 					;    alist
;;       (flet ((test-type-class-name (type-string)
;; 	       (cond ((string= type-string "mf:PositiveSyntaxTest") 'sparql-positive-syntax-test)
;; 		     ((string= type-string "mf:NegativeSyntaxTest") 'sparql-negative-syntax-test)
;; 		     ((string= type-string "mf:PositiveSyntaxTest11") 'sparql-positive-syntax-test-11)
;; 		     ((string= type-string "mf:NegativeSyntaxTest11") 'sparql-negative-syntax-test-11)
;; 		     ((string= type-string "mf:PositiveUpdateSyntaxTest11") 'sparql-positive-update-syntax-test-11)
;; 		     ((string= type-string "mf:NegativeUpdateSyntaxTest11") 'sparql-negative-update-syntax-test-11)
;; 		     ((string= type-string "mf:QueryEvaluationTest") 'sparql-query-evaluation-test)
;; 		     ((string= type-string "mf:UpdateEvaluationTest") 'sparql-update-evaluation-test)
;; 		     ((string= type-string "mf:CSVResultFormatTest") 'sparql-csv-result-format-test)
;; 		     ((string= type-string "mf:ProtocolTest") 'sparql-protocol-test)
;; 		     ((string= type-string "mf:ServiceDescriptionTest") 'sparql-service-description-test)
;; 		     (t (error* "Unknown test type ~A" type-string)))))
;; 	(let ((header-keywords (mapcar #'(lambda (h) (intern-keyword (string-upcase h))) headers)))
;; 	  (make-instance 'sparql-tests2
;; 			 :fields header-keywords
;; 			 :entries (loop for entry in alist
;; 					for key = (first entry)
;; 					for values = (second entry)
;; 					for type-class-name = (test-type-class-name (first key))
;; 					for args = (append (list type-class-name :type (first key) :suite (second key) :collection (third key) :name (fourth key))
;; 							   (loop for keyword in (nthcdr 4 header-keywords)
;; 								 for value in values
;; 								 nconc (list keyword value)))
;; 					for test = (apply #'make-instance args)
;; 					when (equal (fourth key) "add01")
;; 					do (progn (inform "entry = ~S~%args = ~S" entry args) (describe test))
;; 					collect test)))))))

;; (add-sparql-test tests
;; 							     :type type :negative (parse-xsd-boolean negative) :suite suite :collection collection :name name
;; 							     :queryfile queryfile :datafile datafile :graphdatafile graphdatafile
;; 							     :resultfile resultfile :resultgraphfile resultgraphfile :resultgraphlabel resultgraphlabel)
