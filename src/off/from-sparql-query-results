	  ;; ((and (slot-boundp query-results1 'triples) (slot-boundp query-results2 'triples))
	  ;;  (let ((triple-list1 (sparql-query-results-triples query-results1))
	  ;; 	 (triple-list2 (sparql-query-results-triples query-results2)))
	  ;;    (cond ((and (= (length triple-list1) (length triple-list2))
	  ;; 		 (every #'(lambda (tr1 tr2) (equal-triples tr1 tr2)) triple-list1 triple-list2))
	  ;; 	    (when verbosep (format output-stream "~%~:(~A~) and ~(~A~) are equal" result-label1 result-label2))
	  ;; 	    (values t t))
	  ;; 	   ((not (= (length triple-list1) (length triple-list2)))
	  ;; 	    (when verbosep (format output-stream "~%~D ~:(~A~) triples, ~(~A~) ~D triples" result-label1 (length triple-list1) result-label2 (length triple-list2)))
	  ;; 	    (values nil nil))
	  ;; 	   (t
	  ;; 	    (flet ((show-triples (triples) (loop for triple in triples do (format output-stream "~%Triple: [~{~A~^ ~}]" triple))))
	  ;; 	      (let ((observed-minus-expected (set-difference triple-list1 triple-list2 :test #'equal-triples))
	  ;; 		    (expected-minus-observed (set-difference triple-list2 triple-list1 :test #'equal-triples)))
	  ;; 		(cond ((and (null observed-minus-expected) (null expected-minus-observed))
	  ;; 		       (when verbosep
	  ;; 			 (format output-stream "~%~:(~A~) triples and ~(~A~) triples are same, but in a different order~%" result-label1 result-label2)
	  ;; 			 (format output-stream "~%~:(~A~):" result-label1)
	  ;; 			 (show-triples triple-list1)
	  ;; 			 (format output-stream "~%~:(~A~):" result-label2)
	  ;; 			 (show-triples triple-list2)
	  ;; 			 (values t nil)))
	  ;; 		      (t
	  ;; 		       (format output-stream "~%~:(~A~) triples not in ~(~A~):" result-label1 result-label2)
	  ;; 		       (show-triples expected-minus-observed)
	  ;; 		       (format output-stream "~%~:(~A~) triples not ~(~A~):" result-label2 result-label1)
	  ;; 		       (show-triples observed-minus-expected)
	  ;; 		       (values nil nil)))))))))
